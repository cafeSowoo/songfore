<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>독서모임 조 랜덤 배정기</title>
  <style>
    :root {
      --bg: #f6f8ff;
      --card: #ffffff;
      --line: #d8def4;
      --primary: #3f67ff;
      --primary-dark: #2d4fd1;
      --text: #1b2551;
      --muted: #5f6b99;
      --warn: #b06d00;
      --error: #b3261e;
      --ok: #0f8a48;
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Pretendard", "Apple SD Gothic Neo", "Noto Sans KR", sans-serif;
      color: var(--text);
      background: linear-gradient(180deg, #eef2ff 0%, var(--bg) 60%);
    }

    .container {
      width: min(1120px, 94vw);
      margin: 28px auto 60px;
      display: grid;
      gap: 18px;
    }

    h1 {
      margin: 0;
      font-size: clamp(1.4rem, 2vw, 2rem);
    }

    .sub {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .panel {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      box-shadow: 0 8px 24px rgba(26, 39, 87, 0.06);
      padding: 16px;
    }

    .section-title {
      margin: 0 0 12px;
      font-size: 1.05rem;
    }

    .leader-list {
      display: grid;
      gap: 10px;
      margin-bottom: 10px;
    }

    .leader-row {
      display: grid;
      grid-template-columns: 1.2fr auto auto;
      gap: 8px;
      align-items: center;
    }

    input[type="text"], textarea, select {
      width: 100%;
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 0.95rem;
      color: var(--text);
      background: #fff;
    }

    textarea {
      min-height: 120px;
      resize: vertical;
      line-height: 1.4;
    }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
    }

    .field-label {
      font-size: 0.9rem;
      color: var(--muted);
      margin: 0 0 6px;
    }

    .btn-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    button {
      border: 0;
      border-radius: 10px;
      padding: 10px 14px;
      font-size: 0.92rem;
      font-weight: 700;
      cursor: pointer;
      background: #e9edff;
      color: #2a3a8a;
    }

    button.primary {
      background: var(--primary);
      color: #fff;
    }

    button.primary:hover { background: var(--primary-dark); }

    .message {
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 0.92rem;
      margin-top: 10px;
      display: none;
      white-space: pre-wrap;
    }

    .message.show { display: block; }
    .message.error { background: #ffebee; color: var(--error); }
    .message.warn { background: #fff8e1; color: var(--warn); }
    .message.ok { background: #e7f6ed; color: var(--ok); }

    .result-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }

    .group-card {
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      background: #fafbff;
    }

    .group-card h3 {
      margin: 0 0 8px;
      font-size: 1rem;
    }

    .stats {
      font-size: 0.85rem;
      color: var(--muted);
      margin-bottom: 8px;
    }

    .member-list {
      margin: 0;
      padding-left: 18px;
      line-height: 1.5;
    }

    .hint {
      margin-top: 10px;
      font-size: 0.88rem;
      color: var(--muted);
    }

    @media (max-width: 720px) {
      .leader-row { grid-template-columns: 1fr 1fr auto; }
      .grid-2 { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="container">
    <section>
      <h1>독서모임 조 랜덤 배정기</h1>
      <p class="sub">북리더는 고정 배정하고, 참가자는 규칙 기반으로 최대한 균형 있게 랜덤 분배합니다.</p>
    </section>

    <section class="panel">
      <h2 class="section-title">(A) 북리더 입력 (최대 4명)</h2>
      <div id="leaderList" class="leader-list"></div>
      <div class="btn-row">
        <button id="addLeaderBtn" type="button">리더 추가</button>
      </div>
      <p class="hint">리더 수 = 조 개수입니다. (예: 리더 3명 → 3개 조)</p>
    </section>

    <section class="panel">
      <h2 class="section-title">(B) 참가자 입력 (리더 제외)</h2>
      <div class="grid-2">
        <div>
          <p class="field-label">기존 남자 (공백/탭/줄바꿈으로 구분)</p>
          <textarea id="existingMale" placeholder="예) 민수 현우
(또는 탭/줄바꿈으로 구분)"></textarea>
        </div>
        <div>
          <p class="field-label">기존 여자 (공백/탭/줄바꿈으로 구분)</p>
          <textarea id="existingFemale" placeholder="예) 지은	서연
(또는 공백/줄바꿈으로 구분)"></textarea>
        </div>
        <div>
          <p class="field-label">신입 남자 (공백/탭/줄바꿈으로 구분)</p>
          <textarea id="newMale" placeholder="예) 도윤	태오"></textarea>
        </div>
        <div>
          <p class="field-label">신입 여자 (공백/탭/줄바꿈으로 구분)</p>
          <textarea id="newFemale" placeholder="예) 하윤 예린"></textarea>
        </div>
      </div>
      <div class="btn-row">
        <button id="fillSampleBtn" type="button">예시 채우기</button>
      </div>
    </section>

    <section class="panel">
      <h2 class="section-title">배정 실행</h2>
      <div class="btn-row">
        <button id="assignBtn" class="primary" type="button">배정하기</button>
        <button id="reshuffleBtn" type="button">다시 섞기</button>
        <button id="plainCopyBtn" type="button">일반 복사</button>
        <button id="csvBtn" type="button">CSV 다운로드</button>
      </div>
      <div id="statusMessage" class="message"></div>
      <div id="warningMessage" class="message"></div>
      <div id="resultContainer" class="result-grid"></div>
    </section>

    <section class="panel">
      <h2 class="section-title">사용 방법</h2>
      <ol>
        <li>북리더 이름/성별을 입력합니다.</li>
        <li>참가자를 4개 텍스트박스(기존/신입 + 남/여)에 붙여넣습니다. (공백/탭/줄바꿈 모두 가능)</li>
        <li><strong>배정하기</strong>를 누르면 규칙 기반 랜덤 배정 결과가 생성됩니다.</li>
        <li><strong>다시 섞기</strong>로 재추첨하고, <strong>일반 복사/CSV 다운로드</strong>로 공유합니다.</li>
      </ol>
    </section>
  </main>

  <script>
    const leaderListEl = document.getElementById('leaderList');
    const addLeaderBtn = document.getElementById('addLeaderBtn');
    const fillSampleBtn = document.getElementById('fillSampleBtn');
    const assignBtn = document.getElementById('assignBtn');
    const reshuffleBtn = document.getElementById('reshuffleBtn');
    const plainCopyBtn = document.getElementById('plainCopyBtn');
    const csvBtn = document.getElementById('csvBtn');
    const statusMessageEl = document.getElementById('statusMessage');
    const warningMessageEl = document.getElementById('warningMessage');
    const resultContainerEl = document.getElementById('resultContainer');

    let lastResult = null;

    function showMessage(el, type, text) {
      el.className = `message show ${type}`;
      el.textContent = text;
    }

    function hideMessage(el) {
      el.className = 'message';
      el.textContent = '';
    }

    // 표시/복사용 정렬: 리더는 맨 앞, 신입 참가자는 맨 뒤로 보이게 정렬.
    // (배정 로직 자체는 변경하지 않고, 출력 순서만 정리)
    function getDisplayMembers(group) {
      const leader = group.members.find((m) => m.isLeader);
      const participants = group.members.filter((m) => !m.isLeader);
      const existing = participants.filter((m) => !m.newbie);
      const newbies = participants.filter((m) => m.newbie);
      return [leader, ...existing, ...newbies].filter(Boolean);
    }

    function createLeaderRow(leader = { name: '', gender: 'M' }) {
      const row = document.createElement('div');
      row.className = 'leader-row';
      row.innerHTML = `
        <input type="text" class="leader-name" placeholder="리더 이름" value="${leader.name}" />
        <select class="leader-gender">
          <option value="M" ${leader.gender === 'M' ? 'selected' : ''}>남</option>
          <option value="F" ${leader.gender === 'F' ? 'selected' : ''}>여</option>
        </select>
        <button type="button" class="remove-leader">삭제</button>
      `;

      row.querySelector('.remove-leader').addEventListener('click', () => {
        row.remove();
      });

      return row;
    }

    function getLeaderRowsCount() {
      return leaderListEl.querySelectorAll('.leader-row').length;
    }

    function addLeaderRow(leader) {
      if (getLeaderRowsCount() >= 4) {
        showMessage(statusMessageEl, 'error', '북리더는 최대 4명까지 입력할 수 있습니다.');
        return;
      }
      hideMessage(statusMessageEl);
      leaderListEl.appendChild(createLeaderRow(leader));
    }

    // 균등 분배를 위한 목표 배열 생성 함수.
    function makeTargetArray(total, groupCount) {
      const base = Math.floor(total / groupCount);
      const remainder = total % groupCount;
      return Array.from({ length: groupCount }, (_, i) => base + (i < remainder ? 1 : 0));
    }

    function parseNames(text) {
      // 구글 시트 복붙을 고려해 공백/탭/줄바꿈을 모두 구분자로 처리한다.
      // 연속 구분자는 하나로 취급하고, 앞뒤 공백은 제거한다.
      return text
        .trim()
        .split(/\s+/)
        .map((name) => name.trim())
        .filter(Boolean);
    }

    // 중복 이름이 있으면 (2), (3) 꼬리를 붙여 자동 구분하고 경고용 목록을 반환.
    function dedupePeople(people) {
      const counts = new Map();
      const duplicatedBaseNames = new Set();

      const deduped = people.map((person) => {
        const base = person.name;
        const current = counts.get(base) || 0;
        counts.set(base, current + 1);

        if (current === 0) return person;

        duplicatedBaseNames.add(base);
        return {
          ...person,
          name: `${base} (${current + 1})`
        };
      });

      return {
        deduped,
        duplicatedBaseNames: Array.from(duplicatedBaseNames)
      };
    }

    function gatherInputData() {
      const leaderRows = Array.from(leaderListEl.querySelectorAll('.leader-row'));
      const leaders = leaderRows.map((row) => ({
        name: row.querySelector('.leader-name').value.trim(),
        gender: row.querySelector('.leader-gender').value,
        newbie: false,
        isLeader: true
      })).filter((leader) => leader.name);

      const participants = [
        ...parseNames(document.getElementById('existingMale').value).map((name) => ({ name, gender: 'M', newbie: false, isLeader: false })),
        ...parseNames(document.getElementById('existingFemale').value).map((name) => ({ name, gender: 'F', newbie: false, isLeader: false })),
        ...parseNames(document.getElementById('newMale').value).map((name) => ({ name, gender: 'M', newbie: true, isLeader: false })),
        ...parseNames(document.getElementById('newFemale').value).map((name) => ({ name, gender: 'F', newbie: true, isLeader: false }))
      ];

      const allPeople = [...leaders, ...participants];
      const { deduped, duplicatedBaseNames } = dedupePeople(allPeople);
      const dedupedLeaders = deduped.filter((p) => p.isLeader);
      const dedupedParticipants = deduped.filter((p) => !p.isLeader);

      return {
        leaders: dedupedLeaders,
        participants: dedupedParticipants,
        duplicatedBaseNames
      };
    }

    function shuffle(arr) {
      const cloned = [...arr];
      for (let i = cloned.length - 1; i > 0; i -= 1) {
        const j = Math.floor(Math.random() * (i + 1));
        [cloned[i], cloned[j]] = [cloned[j], cloned[i]];
      }
      return cloned;
    }

    function evaluateGroups(groups, targets) {
      const sizePenalty = groups.reduce((sum, group, i) => sum + Math.abs(group.members.length - targets.sizes[i]), 0);
      const newbiePenalty = groups.reduce((sum, group, i) => sum + Math.abs(group.newbieCount - targets.newbies[i]), 0);
      const malePenalty = groups.reduce((sum, group, i) => sum + Math.abs(group.maleCount - targets.males[i]), 0);
      const femalePenalty = groups.reduce((sum, group, i) => {
        const femaleCount = group.members.length - group.maleCount;
        return sum + Math.abs(femaleCount - targets.females[i]);
      }, 0);

      // 조 크기 균등은 가장 중요하므로 가중치를 크게 준다.
      const score = sizePenalty * 1000 + newbiePenalty * 260 + malePenalty * 50 + femalePenalty * 50;
      return { score, sizePenalty, newbiePenalty, malePenalty, femalePenalty };
    }

    function assignWithBestOfN(leaders, participants, tries = 1000) {
      const groupCount = leaders.length;
      const totalPeople = leaders.length + participants.length;
      const totalNewbies = [...leaders, ...participants].filter((p) => p.newbie).length;
      const totalMales = [...leaders, ...participants].filter((p) => p.gender === 'M').length;

      const targetSizes = makeTargetArray(totalPeople, groupCount);
      const targetNewbies = makeTargetArray(totalNewbies, groupCount);
      const targetMales = makeTargetArray(totalMales, groupCount);
      const targetFemales = targetSizes.map((size, i) => size - targetMales[i]);

      const targets = {
        sizes: targetSizes,
        newbies: targetNewbies,
        males: targetMales,
        females: targetFemales
      };

      let best = null;

      for (let attempt = 0; attempt < tries; attempt += 1) {
        // 리더를 먼저 각 조에 고정 배치.
        const groups = leaders.map((leader, idx) => ({
          name: `${idx + 1}조 (${leader.name})`,
          leader,
          members: [leader],
          newbieCount: leader.newbie ? 1 : 0,
          maleCount: leader.gender === 'M' ? 1 : 0
        }));

        // 희소 속성(신입/소수 성별)을 먼저 보게 하여 균형을 맞추기 쉽게 한다.
        const shuffled = shuffle(participants);

        // 참가자 목표치(리더 배정 반영)를 계산해, 부족한 속성을 먼저 채우도록 유도한다.
        const participantNeedPerGroup = groups.map((g, i) => ({
          size: Math.max(0, targets.sizes[i] - g.members.length),
          newbie: Math.max(0, targets.newbies[i] - g.newbieCount),
          male: Math.max(0, targets.males[i] - g.maleCount),
          female: Math.max(0, targets.females[i] - (g.members.length - g.maleCount))
        }));

        const totalNeed = participantNeedPerGroup.reduce((acc, need) => ({
          size: acc.size + need.size,
          newbie: acc.newbie + need.newbie,
          male: acc.male + need.male,
          female: acc.female + need.female
        }), { size: 0, newbie: 0, male: 0, female: 0 });

        const ordered = shuffled.sort((a, b) => {
          const rarityA = (a.newbie && totalNeed.newbie > 0 ? 3 : 0) + (a.gender === 'M' && totalNeed.male > 0 ? 2 : 0) + (a.gender === 'F' && totalNeed.female > 0 ? 2 : 0);
          const rarityB = (b.newbie && totalNeed.newbie > 0 ? 3 : 0) + (b.gender === 'M' && totalNeed.male > 0 ? 2 : 0) + (b.gender === 'F' && totalNeed.female > 0 ? 2 : 0);
          return rarityB - rarityA;
        });

        for (const person of ordered) {
          let bestGroupIndex = -1;
          let bestScore = Infinity;

          // 신입은 목표 신입 수를 아직 채우지 못한 조에 우선 배치한다.
          // 예: 신입 2명/3조라면 targetNewbies = [1,1,0]이므로 2명이 같은 조로 몰리지 않도록 유도.
          const groupNeedNewbie = groups.map((g, i) => Math.max(0, targets.newbies[i] - g.newbieCount));
          const mustPlaceToNewbieNeedGroup = person.newbie && groupNeedNewbie.some((need) => need > 0);

          for (let i = 0; i < groups.length; i += 1) {
            const g = groups[i];

            // 이 사람을 해당 조에 넣었을 때의 부족/초과를 점수화.
            const sizeAfter = g.members.length + 1;
            const newbieAfter = g.newbieCount + (person.newbie ? 1 : 0);
            const maleAfter = g.maleCount + (person.gender === 'M' ? 1 : 0);
            const femaleAfter = sizeAfter - maleAfter;

            const remainingCapacity = targets.sizes[i] - g.members.length;
            if (remainingCapacity <= 0) {
              continue;
            }

            if (mustPlaceToNewbieNeedGroup && groupNeedNewbie[i] <= 0) {
              continue;
            }

            const sizeGap = Math.max(0, sizeAfter - targets.sizes[i]);
            const sizeLack = Math.max(0, targets.sizes[i] - sizeAfter);
            const newbieGap = Math.max(0, newbieAfter - targets.newbies[i]);
            const newbieLack = Math.max(0, targets.newbies[i] - newbieAfter);
            const maleGap = Math.max(0, maleAfter - targets.males[i]);
            const maleLack = Math.max(0, targets.males[i] - maleAfter);
            const femaleGap = Math.max(0, femaleAfter - targets.females[i]);
            const femaleLack = Math.max(0, targets.females[i] - femaleAfter);

            const localScore = sizeGap * 500 + sizeLack * 120 + newbieGap * 220 + newbieLack * 140 + maleGap * 50 + maleLack * 25 + femaleGap * 50 + femaleLack * 25 + Math.random() * 2;

            if (localScore < bestScore) {
              bestScore = localScore;
              bestGroupIndex = i;
            }
          }

          // 안전장치: 모든 후보가 배제된 경우(드문 케이스), 남은 자리가 있는 조 중 랜덤 선택.
          if (bestGroupIndex === -1) {
            const availableIndices = groups
              .map((g, i) => ({ i, remain: targets.sizes[i] - g.members.length }))
              .filter((it) => it.remain > 0)
              .map((it) => it.i);
            bestGroupIndex = availableIndices[Math.floor(Math.random() * availableIndices.length)] ?? 0;
          }

          const targetGroup = groups[bestGroupIndex];
          targetGroup.members.push(person);
          if (person.newbie) targetGroup.newbieCount += 1;
          if (person.gender === 'M') targetGroup.maleCount += 1;
        }

        const metrics = evaluateGroups(groups, targets);
        const candidate = { groups, targets, metrics };

        if (!best || candidate.metrics.score < best.metrics.score) {
          best = candidate;
          if (candidate.metrics.score === 0) break;
        }
      }

      return best;
    }

    function buildSummary(result) {
      return result.groups.map((group, idx) => {
        const male = group.members.filter((m) => m.gender === 'M').length;
        const female = group.members.filter((m) => m.gender === 'F').length;
        const newbie = group.members.filter((m) => m.newbie).length;
        const members = getDisplayMembers(group).filter((m) => !m.isLeader).map((m) => m.name).join(', ') || '없음';

        return `${idx + 1}조 (${group.leader.name})\n- 리더: ${group.leader.name} (${group.leader.gender === 'M' ? '남' : '여'})\n- 구성원: ${members}\n- 통계: 총원 ${group.members.length}명 / 남 ${male} / 여 ${female} / 신입 ${newbie}`;
      }).join('\n\n');
    }

    function renderResult(result, warnings = []) {
      resultContainerEl.innerHTML = '';

      result.groups.forEach((group, idx) => {
        const total = group.members.length;
        const male = group.members.filter((m) => m.gender === 'M').length;
        const female = group.members.filter((m) => m.gender === 'F').length;
        const newbie = group.members.filter((m) => m.newbie).length;

        const card = document.createElement('article');
        card.className = 'group-card';

        const membersHtml = getDisplayMembers(group)
          .map((member) => {
            if (member.isLeader) {
              return `<li><strong>리더: ${member.name}</strong> (${member.gender === 'M' ? '남' : '여'})</li>`;
            }
            return `<li>${member.name} (${member.gender === 'M' ? '남' : '여'}${member.newbie ? ', 신입' : ''})</li>`;
          })
          .join('');

        card.innerHTML = `
          <h3>${idx + 1}조 · ${group.leader.name}조</h3>
          <div class="stats">총원 ${total}명 · 남 ${male} · 여 ${female} · 신입 ${newbie}</div>
          <ul class="member-list">${membersHtml}</ul>
        `;

        resultContainerEl.appendChild(card);
      });

      const score = result.metrics.score;
      if (score === 0) {
        showMessage(statusMessageEl, 'ok', '모든 규칙을 만족합니다.');
      } else {
        showMessage(statusMessageEl, 'warn', '최대한 균형에 가깝게 배정했지만 일부 제약을 완벽히 만족할 수 없습니다.');
      }

      if (warnings.length) {
        showMessage(warningMessageEl, 'warn', warnings.join('\n'));
      } else {
        hideMessage(warningMessageEl);
      }
    }

    function runAssignment() {
      hideMessage(statusMessageEl);
      hideMessage(warningMessageEl);

      const { leaders, participants, duplicatedBaseNames } = gatherInputData();
      const warnings = [];

      if (leaders.length === 0) {
        showMessage(statusMessageEl, 'error', '리더가 0명이라 배정할 수 없습니다. 리더를 1명 이상 입력하세요.');
        return;
      }

      if (leaders.length > 4) {
        showMessage(statusMessageEl, 'error', '리더는 최대 4명까지 가능합니다.');
        return;
      }

      if (duplicatedBaseNames.length > 0) {
        warnings.push(`중복 이름이 감지되어 자동으로 구분 표기했습니다: ${duplicatedBaseNames.join(', ')}`);
      }

      const groupCount = leaders.length;
      const totalPeople = leaders.length + participants.length;
      const targetSizes = makeTargetArray(totalPeople, groupCount);
      const minTarget = Math.min(...targetSizes);
      const maxTarget = Math.max(...targetSizes);

      if (minTarget < 4 || maxTarget > 7) {
        warnings.push('현재 인원으로 조당 4~7명을 만족하기 어렵습니다. 가능한 한 균형 배정 결과를 제공합니다.');
      }

      const result = assignWithBestOfN(leaders, participants, 1000);
      const constraintsReason = [];
      if (result.metrics.sizePenalty > 0) constraintsReason.push('조별 총원 균등');
      if (result.metrics.newbiePenalty > 0) constraintsReason.push('신입 분산');
      if (result.metrics.malePenalty > 0) constraintsReason.push('성비 균형');

      if (constraintsReason.length) {
        warnings.push(`완벽 만족이 어려운 제약: ${constraintsReason.join(', ')}`);
      }

      renderResult(result, warnings);
      lastResult = {
        ...result,
        textSummary: buildSummary(result)
      };
    }

    function fillSampleData() {
      leaderListEl.innerHTML = '';
      addLeaderRow({ name: '민준', gender: 'M' });
      addLeaderRow({ name: '지현', gender: 'F' });
      addLeaderRow({ name: '서윤', gender: 'F' });

      document.getElementById('existingMale').value = '도현\n우진\n준호\n시우';
      document.getElementById('existingFemale').value = '유진\n채원\n소희\n나은\n하린';
      document.getElementById('newMale').value = '지후\n태오';
      document.getElementById('newFemale').value = '하윤\n예린\n다인';

      hideMessage(statusMessageEl);
      hideMessage(warningMessageEl);
      resultContainerEl.innerHTML = '';
      lastResult = null;
    }

    async function copyPlainResult() {
      if (!lastResult) {
        showMessage(statusMessageEl, 'error', '먼저 배정 결과를 생성해 주세요.');
        return;
      }

      const plainLines = lastResult.groups
        .map((group) => getDisplayMembers(group).map((m) => m.name).join(' '))
        .join('\n');

      try {
        await navigator.clipboard.writeText(plainLines);
        showMessage(statusMessageEl, 'ok', '조별 이름 목록을 클립보드에 복사했습니다.');
      } catch (error) {
        showMessage(statusMessageEl, 'error', '복사에 실패했습니다. 브라우저 권한을 확인해주세요.');
      }
    }

    function downloadCsv() {
      if (!lastResult) {
        showMessage(statusMessageEl, 'error', '먼저 배정 결과를 생성해 주세요.');
        return;
      }

      const rows = [['조', '이름', '역할', '성별', '신입여부']];
      lastResult.groups.forEach((group, idx) => {
        group.members.forEach((member) => {
          rows.push([
            `${idx + 1}조`,
            member.name,
            member.isLeader ? '리더' : '참가자',
            member.gender === 'M' ? '남' : '여',
            member.newbie ? '신입' : '기존'
          ]);
        });
      });

      const csv = rows.map((row) => row.map((cell) => `"${String(cell).replaceAll('"', '""')}"`).join(',')).join('\n');
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = '독서모임_조배정결과.csv';
      a.click();
      URL.revokeObjectURL(url);
    }

    addLeaderBtn.addEventListener('click', () => addLeaderRow());
    fillSampleBtn.addEventListener('click', fillSampleData);
    assignBtn.addEventListener('click', runAssignment);
    reshuffleBtn.addEventListener('click', runAssignment);
    plainCopyBtn.addEventListener('click', copyPlainResult);
    csvBtn.addEventListener('click', downloadCsv);

    // 초기 화면에 리더 입력칸 2개를 준비.
    addLeaderRow();
    addLeaderRow();
  </script>
</body>
</html>
